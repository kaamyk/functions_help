J00 ex00:
On envois un mal donc rien compliquer.

J00 ex01 :
chmod 457(random) fichier.ext

J00 ex02 :
même chose qu'au dessus.
Pour faire les liens symboliques entre les fichiers => ln -s(ymbolique) fichier1 fichier2 
le fichier 2 sera lié au 1 qui menera au code.
Le lien symbolique est un raccourci qui mène au fihcier et non au binaire. Sinon c'est un lien physique.

Pour exécuter un fichier .sh : MODIFIER LES DROITS
grep affiche les fichiers ou répertoires qui correspondent à un pattern donné 
awk permet d'effectuer une action. On peut mettre un mini bout de code.

J00 ex 03 :
Lesystème est sur wikipédia.
Kerberos est une librairie qu'on trouve sur Github.
Pour créer un ticket kerberos :   kinit login
Pour détruire un ticket       :	kdestroy.

J00 ex 06 :
ldif est un format de fichier qui contiennent des infos répertoriées comme un dictionnaire.
Il faut simplement se chercher dans les fichiers avec un ldapsearch pour retrouver ses infos.
après, changetype :
For example:

dn:cn=Barbara Fritchy,ou=Sales,o=Oracle,c=US
changetype:modify
add: work-phone
work-phone:510/506-7000
work-phone:510/506-7001


J00 ex 07 :
ls -mpt
m : virgules 
p : met un / derriere les fichiers 
t : ordonne par date de création

https://docs.oracle.com/cd/A81042_01/DOC/network.816/a77230/syntax.html

J01 Ex 1 :
FT_USER = nvjksvn
groups $FT_USER | tr ' ' ',' | tr -d '\n'

J01 Ex 2 :
find -name *.sh | sed 's#.*\##'

sed 's...' permetde rehercher u motif et le remplacer par un autre ex : s/motifRecherché/motifSubstitut/
On peut rajouter 'g' à la fin pour que le changement se fasse dans toutes les occurences d'un text en cours de lecture par exemple

J01 Ex 3 :
find ./ | wc -l

J01 Ex 4 :
ifconfig -a | grep ether | awk '{print $2}'
ether correspond dans le cas Linux à Ethernet mais modifiable du coup. Et le awk doit changer aussi en fonction du format de la connexion.

J01 Ex 5 :
 touch \"\\\?\$\*'KwaMe'\*\$\?\\\"
Mettre \ avant les caractères spéciaux permet de dire au Pc que ce ne sont pas des acaractère utiles
FAIRE ATTENTION AUX DROITS (il faut qu'ils correspondent au sujet)

J01 Ex 6 :
 ls -l | awk 'NR % 2 == 0'
NR = number of record =>le ombre de résultats retournés

J01 Ex 7 :
#!/bin/bash
FT_LINE1=2
FT_LINE2=17

cat /etc/passwd | sed -e 's/:.*//g' | sed -n 'n;p' | rev | sort -r | head -n ${FT_LINE2-1} | tail -n $((${FT_LINE2}-${FT_LINE1}+1)) | tr '\n' ', ' | sed 's/,$/./'

#cat /etc/passwd | sed -e 's/:.*//g' | sed -n 'n;p' | rev | sort -r | tr '\n' ', ' | sed 's/$/./'
(juste pour vérifier que ce sont les bon rangs qui s'affichent)

commande demandéé | supprime les commentaires | affiche 1/2 ligne à partir de 2 | retourne les lignes | retourne TOUTES les lignes | affiche jusqu'à la dernière ligne | supprime les premières lignes | remplace les \n par des , | remplace la dernière , par un . 

J01 Ex8 :




gcc -o nomfichier nomfichier.ext => Créer un exéécutable /!\ il faut le refaire à cahque essai/!\

write (sortie standard du fichier, chaîne de caractère, taille en octet)

JO2 Ex00 :

programme : 
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>

int     ft_putchar(char c)
{
        return (write(1, &c, 1));
}

void    ft_print_alphabet(void)
{
        char c;
 
        c = 'a';
        while (c++ <= 'z')
        {
                ft_putchar(c - 1);
        }
}
 
 int     main(void)
 {
         ft_print_alphabet();
         ft_putchar('\n');   
         return (0);
}
BIEN PENSER À RENDRE UNIQUEMENT LA FONCTION DEMANDÉE

J02 Ex01 :

Programme :
  1 #include <stdlib.h>
  2 #include <stdio.h>
  3 #include <unistd.h>
  4 
  5 int     ft_putchar(char c)
  6 {
  7         return (write(1, &c, 1));
  8 }
  9 
 10 void    ft_print_alphabet(void)
 11 {
 12         char c;
 13 
 14         c = 'z';
 15         while (c-- >= 'a')
 16         {
 17                 ft_putchar(c + 1);
 18         }
 19 }
 20 
 21 int     main(void)
 22 {
 23         ft_print_alphabet();
 24         ft_putchar('\n');       
 25         return (0);
 26 }
BIEN PENSER À RENDRE UNIQUEMENT LA FONCTION DEMANDÉE

J02 Ex 02 :
Programme :
  1 #include <stdio.h>
  2 #include <stdlib.h>
  3 #include <unistd.h>
  4 
  5 
  6 int 	ft_putchar(char c)
  7 {
  8         return (write(1, &c, 1));
  9 }
 10 
 11 void 	ft_print_numbers(void)
 12 {
 13         char c;
 14         c = '0';
 15  
 16         while (c++ <= '9')
 17         {
 18                 ft_putchar(c - 1);
 19         }
 20 }
 21 
 22 int     main(void)
 23 {
 24         ft_print_numbers();
 25         ft_putchar('\n');
 26         return (0);
 27 }
BIEN PENSER À RENDRE UNIQUEMENT LA FONCTION DEMANDÉE

J02 Ex 03 : 
Programme :
  1 #include <unistd.h>
  2 
  3 int     ft_putchar(char c)
  4 {
  5         return (write(1, &c, 1));
  6 }
  7 
  8 void    ft_is_negative(int n)
  9 {
 10         if (n >= 0)
 11         {
 12                 ft_putchar('P');
 13         }
 14 
 15         else
 16         {
 17                 ft_putchar('N');
 18         }
 19 
 20 }
 21 
 22 int     main()
 23 {
 24         ft_is_negative(6);
 25         ft_putchar('\n');
 26         return(0);
 27 }

J02 Ex 04 :
  1 #include <unistd.h>
  2 void ft_print_comb(void)
  3 {   
  4     char    i;
  5     char    j;
  6     char    k;
  7  
  8     for (i = '0'; i <= '7'; i++)
  9     {   
 10         for (j = i + 1; j <= '8'; j++)
 11         {   
 12             for (k = j + 1; k <= '9'; k++)
 13             {   
 14                 write(1, &i, 1);
 15                 write(1, &j, 1);
 16                 write(1, &k, 1);
 17                 
 18                 if (!(i == '7' && j == '8' && k == '9'))
 19                     write(1, ", ", 2);
 20             }
 21         }
 22     }
 23 }


On fait une chaîne de caractères avec ',' et ' ' contenus de base dedans.

On vérifie que les centaines != '7' qui est la dernière centaine possible dans ce cas on n'écrit que 3 bytes car pas de ',' ou ' ' nécessaires.

Dans les boucles on incrémentes et on vérifie qu'on arrive pas à la limite.
Si le unité ne le sont pas on vérifie que les dizaine non plus en le incrémentant au passage.
Si les dizaines sont incrémentées, on fait unités == centaines + 1 car elles soivent forcément^être supérieures.

J02 Ex 05 :
Pogramme :
  1 #include <unistd.h>
  2 
  3 char    ft_putchar(char c)
  4 {
  5     write (1, &c, 1);
  6 }
  7 
  8 void ft_print_comb2(void)
  9 {
 10     int     i;
 11     int     j;
 12 
 13     i = 0;
 14     j = 1;
 15 
 16     while (i < 99)
 17     {
 18         ft_putchar ((i / 10) + '0');
 19         ft_putchar ((i % 10) + '0');
 20         ft_putchar (' ');
 21         ft_putchar ((j / 10) + '0');
 22         ft_putchar ((j % 10) + '0');
 23      
 24         if (!(i == 98 && j == 99))
 25             write (1, ", ", 2);
 26         if (j++ >= 99)
 27         {
 28             i++;
 29             j = i + 1;
 30         }
 31     
 32     }
 33 }


D'abord se poser les questions des limites : quand se finit le programme, qu'est-ce-qui déclenche la fin. (voir toutes les possibilité).
A l'inverse qu'est ce qui fait que le programme continue?

J02 Ex 06 :
Programme :
#include <unistd.h>

void    ft_putchar(char c)
{
        write(1, &c, 1);
}

void    ft_putnbr(int nb)
{
        unsigned int n;

        if (nb < 0)
        {
                ft_putchar('-');
                n = -nb;
        }
        else
                n = nb;
        if (n > 9)
        {
                ft_putnbr(n / 10);
                n %= 10;
        }
        ft_putchar(n + '0');
}

Décomposer le problème et les éléments qui le constituent.
Voir plusieurs façon d'aborder le problème.

J02 Ex 07 : 
Bien prendre en compte tous les paramètres et considérer comme acquis ceux qui le sont. 
Ex ici, on sait que n DOIT et SERA comprit entre 0 et 10.

#include <unistd.h>

void    ft_print_combn(int n)
{
        char    t[11];
        int             i;

        if (n < 1 || n > 9)
                return ;
        *t = '0';
        i = 0;
        while (++i < n)
                t[i] = t[i - 1] + 1;
        t[n] = ',';
        t[n + 1] = ' ';
        while (*t <= 58 - n)
        {
                write(1, t, n + ((*t != 58 - n) ? 2 : 0));
                i = n;
                while (i--)
                        if (++t[i] <= 58 - n + i)
                                break ;
                while (++i > 0 && i < n)
                        t[i] = t[i - 1] + 1;
        }
}

PAS COMPRIS POURQUOI 58 ? 58 = valeur ascii de '9'

Dans le while :
Tant que le premier caractère est inférieur ou égal à ‘9’ - (nb de caractère) :
        Si 1er char est différent de ‘9’ - (nb char) on écrit (nb char + ‘, ‘) sinon (nbchar )
        On parcours la chaine depuis le dernier char ET SI char++ est inf à son max break
        Tant que i++ strictement inférieur à n (donc pour les unité ça marche pas parce i++ = n)
        Le rang d’après = rang d’avant + 1 (donc que si on modife une dizaine ou plus).




J03 Ex 00 :
Programme :
#include <stdio.h>
void ft_ft(int *nbr)
{
        *nbr = 42;
}
int             main(void)
{
        int     a;

        ft_ft(&a);
        printf("%d", a);
}

VÉRIFIER SI LE PRINTF EST AUTORISÉ OU VOIR COMMENT FAIRE AVEC WRITE.

J03 Ex 01 :
DANS LE MAIN.H PAS BESOIN D'INCLUDE LE MAIN.C MAIS IL FAUT INCLUDE LES FICHIERS DE FONCTION.C POUR POUVOIR DÉFINIR LES PROTOTYPES DE FONCTIONS.
Programme:
#include <stdio.h>

void            ft_ultimate_ft(int *********nbr)
{
        *********nbr = 42;
}

int             main(void)
{
        int a = 5;
        int *b = &a;
        int **c = &b;
        .
        .
        .
        int *********j = &i;

        ft_ultimate_ft(j);
        printf("%d", a);
}

VISIBLEMENT ON PREND L'ADRESSE DU POINTEUR POUR "LUI RAJOUTER UNE ÉTOILE"

J03 Ex 02 :
Programme :
#include <stdio.h>

void            ft_div_mod(int a, int b, int *div, int *mod)
{
        *div = a / b;
        *mod = a % b;
}

int             mai()
{
        int     a = 4;
        int     b = 5;
        int div;
        int mod;

        ft_div_mod(a, b, &div, &mod);

        printf("%d", div);
        printf("%d", mod);
        return (0);
}

On créer une variable.
On envoit à la fonction l'adresse de la variable.
La fonction récupère fait un pointeur sur l'adresse envoyée et récupère la valeur.
La fonction change la valeur contenue.
On imprime la variable.

J03 Ex 03 :
Programme :
#include <stdio.h>

void            ft_ultimate_div_mod(int *a, int *b)
{
        *a /= *b;
        *b = *a % *b;
}

int main()
{
        int             a;
        int             b;

        a = 35;
        b = 12;

        ft_ultimate_div_mod(&a, &b)

        printf("%d", a);
        printf("%d", b);

        return (0);
}

J03 Ex 04 :
Programme :
#include <unistd.h>

void putchar(char c)
{
        write(1, &c, 1);
}

void            ft_putstr(char *str)
{
        while (*str++)
                ft_putchar(*(str - 1));

        ft_putchar('\n');
}

int             main()
{
        chat str[] = "chaine";

        ft_putstr(str);
        write(1, "\n", 1);
        return (0);
}
Chaine de caractère = tableau.
La première case est un pointeur vers la valeur du premier caractère.
Dans putstr : tant qu'il y a une valuer associé au pointeur on write la valeur puis on incrémente le pointeur d'une case (1 bit en l'occurence).

J03 Ex 05 :
Programme :
int             ft_strlen(char *str)
{
        char    *ptr;
        ptr = str;
        while(*ptr)
        {
                ptr++;
        }
        return (ptr - str);
}

int             main()
{
        char    str[] = "babouin";
        int     a;
        a = ft_strlen(str);
        printf("%d", a);
        printf("\n");
        return (0);
}

J03 Ex 06 :
Programme:
void     ft_swap(int *a, int *b)
{
        int tmp;

        tmp = *a;
        *a = *b;
        *b = tmp;
}

int     main()
{
        int     a;
        int     b;

        ft_swap(&a, &b);
        printf("a = %d", a);
        printf("b = %d", b);
        return (0);
}

J03 Ex 07 :
Programme :

  2 void    ft_swap(char *a, char *b)
  3 {   
  4     char    tmp;
  5     
  6     tmp = *a;
  7     *a = *b;
  8     *b = tmp;
  9 }
 10 int         ft_strlen(char *str)
 11 {   
 12     char *ptr;
 13     ptr = str;
 14     
 15     while (*ptr)
 16         ptr++;
 17     
 18     return (ptr - str);
 19 }
 20 char        *ft_strrev(char *str)
 21 {   
 22     int     i;
 23     int     size = (ft_strlen(str) - 1);
 24     
 25     
 26     for (i = 0; i <= (size / 2); i++)
 27     {
 28         ft_swap(&str[i], &str[size - i]);
 29     }   
 30 }


int     main()
{
        char str[] = "cheval";

        printf("%s => ", str);
        printf("%s\n", ft_strrev(str));
        return (0);
}

Ici on apprend les pointeurs de fonctions.
Fonctionnent comme les pointeurs classique sauf que qu'un fonction est de base un pointeur donc juste dans le prototype on met un * et pas dans le main : ça change rien.

Difficulté ici faire en sorte que rts soit une array assez large et pas un simple pointeur sinon ça fait de la merde.


J03 ex 08 :

 1 int     ft_atoi(char *str)
  2 {
  3     int     i;
  4     int     result;
  5     int     is_negative;
  6     char    j;
  7 
  8     i = 0;
  9     is_negative = 0;
 10     result = 0;
 11 
 12     while (str[i++])
 13         if (!((str[i - 1] <= '9' && str[i - 1] >= '0') || str[i - 1] == '-' || st
 14             return 0;
 15 
 16     if (str[0] == '-')
 17         is_negative = 1;
 18 
 19     i = (is_negative == 1) ? 1 : 0;
 20     while (str[i++])
 21     {
 22         for (j = '0'; j <= '9'; j++)
 23         {
 24                 if (str[i - 1] == j)
 25                 {
 26                     result *= 10;
 27                     result += (j - '0');
 28                 }
 29         }
 30     }
 31     if (is_negative == 1)
 32         result *= (-1);
 33 
 34     return (result);
 35 }



J03 ex09 :

Programme :
#include <stdio.h>

void 	ft_sort_integer_table(int *tab, int size)
{
	int 	i;
	int 	j;
	int 	tmp;

	i = 0;

	while ((j = 0) || i ++ < size - 1)
	{
		while (j++ < size - 1)
			if (tab[j - 1] > tab [j])
			{
				tmp = tab[j];
				tab[j] = tab[j - 1];
				tab[j - 1] = tmp;
			}
	}
}

int 	main()
{
	int 	tab[100] = {12, 67, 6 , 78, 576, 11};
	int i;

	i = 0;

	while (tab[i])
		i++;

	ft_sort_integer_table(tab, i);

	return (0);
}

on utilise size - 1 parce que i compte le nombre de case mais la numérotation part de 0.

Dans la fonction : on parours deux fois la fonction, i parours pour sélectionner la case,
et j parcours pour le comparer à toutes les cases.

et après quand une occasion se présente on échange deux caractère.

On passe size fois au carré dans le tableau. Donc même si un nb inf à tous les autres est en dernier il pourra remonter tout le tableau.

on swap tab[j - 1] et tab[j] size au carré fois.










J04 ex 00:
Programme :
#include <stdio.h>

int 	ft_iterative_factorial(int nb)
{
	int 	i;
	int 	result;

	i = 1;
	result = 1;

	while (i++ <= nb)
	{
		result *= i;
	}

	return (result);
}

int		main()
{
	printf("%d\n", ft_iterative_factorial(5));
	return (0);
}

J04 ex 01 :
Programme :
#include "main.h"
#include <stdio.h>

int     ft_recursive_factorial(int nb)
{
        if (nb <= 0)
                return 1;
        else
                return (nb * ft_recursive_factorial(nb - 1));

}

int     main()
{       
        printf("%d\n", ft_recursive_factorial(0));
        return (0);
}      

J04 ex 02 :

#include "main.h"
#include <stdio.h>

int     ft_iterative_power(int nb, int power)
{       
        int     result;
 
        result = 1;

        if(power == 0)
        {
        	return (0);
        }

        while (power-- > 0)
        {
                result *= nb;
        }
 
        return (result);
}


int     main()
{       
        printf("%d\n", ft_iterative_power(5, 2));
 
        return (0);
}

J04 ex 03 :
Programme :
#include <stdio.h>

 int     ft_recursive_power(int nb, int power)
  2 {   
  3     if (power <= 1)
  4         return ((power) ? nb : 0);
  5  
  6     return(nb * ft_recursive_power(nb , power - 1));
  7 }

int 	main()
{
	printf("%d\n", ft_recursive_power(4, 6));
	return (0);
}

Quand on arrive à power = 1 la fonction renvois nb donc réaction en chaîne de nb * nb dans le deuxième return.





J04 ex 04 :
Programme :
#include <stdio.h>

int 	ft_fibonacci(int index)
{
	if (index <= 1)
		return((i <= 0) ? -1 : index);
	else
		return(ft_fibonacci (index - 1) + ft_fibonacci(index -2))
}

int 	main(void)
{
	int 	i;
	i = 0;

	while(i++ <= 17)
		(i == 100) ? printf("%d\n", ft_fibonacci(i) : ft_fibonacci(i));

	return (0);
}

J04 ex 05 :
Programme :
#include <stdio.h>

int 	ft_sqrt(int nb)
{
	int 	i;
	i = 0;

	while (1)
	{
		if (i * i < nb)
			i++;
		else 
		return((i * i == nb) ? i : 0);
	}
}

int 	main(void)
{
	printf("%d\n", ft_sqrt(34));

	return (0);
}

J04 ex 06 :
Programme :
#include <stdio.h>

int 	ft_is_prime(int nb)
{
	int 	i;
	i = 0;

	while (0 < i++ <= 9)
	{
		if (i = nb && i != 1)
		{
			if (nb % i == 0)
				return 0;
			if (i == 9)
				return 1;
		}
	}
}

int 	main(void)
{
	printf("%d\n", ft_is_prime(67));
	return (0);
}

J04 ex 07 :
#include <stdio.h>

int 	ft_find_next_prime(int nb)
{
	int 	i;

	i = 0;

	while (0 < i++ <= 9)
	{
		if (i != 1 && i != nb)
		{
			if (i == 9)
			{
				return (nb);
			}
			if (nb % i == 0)
			{
				while(nb)
				{
					i = 0;
					while (0 < i++ <= 9)
					{
						if (i != 1 && i != nb)
						{
							if (i == 9)
								return nb;
							if (nb % i == 0)
								nb ++;
						}
					}
				}
			}
		}
	}
}

int 	main(void)
{
	printf("reponse = %d\n", ft_find_next_prime(37));

	return (0);
}

J04 ex 08 :

#ifndef MAIN_H
#define MAIN_H
#include "ft_strcapitalize.c"
char    *ft_strcapitalize(char *str);
#endif

J05 ex 00:
Programme :
#include <stdio.h>

char    *ft_strcpy(char *dest, char *src)
{
        int     i;
        i = 0;
        while (src[i++])
        {
                dest[i - 1] = src[i - 1];
        }       
        dest[i - 1] = '\0';
        return (dest);
} 

int     main(void)
{       
        char    src[] = "blabla";
        char    dest[100];
 
        printf("dest = %s\n", ft_strcpy(dest, src));
        
        return(0);
}

J05 ex 01 :
Programme:
#include "main.h"
#include <stdio.h>

char    *ft_strncpy(char *dest, char *src, unsigned int n)
{
        int      i;
        i = 0;
         
        for (i = 0; i < n && src[i] != '\0'; i++)
                dest[i] = src[i];
        for ( ; i < n; i++)
                dest[i] = '\0';
 
        return dest;
}

int     main(void)
{       
        char    src[] = "la bidoune";
        char    dest[100];

        printf("la fonction = %s", ft_strncpy(dest, src, 10));
        printf("\n");
        return (0);
}



J05 ex 02 :
Programme :
#include "main.h"
#include <stdio.h>

char    *ft_strstr(char *str, char *to_find)
{
int     i;
int     j;


i = 0;
 
while(str[i++] && ((j = 0) || 1))
{
        if (str[i - 1] == to_find[j])
        {
                while (to_find[j] && str[i + j - 1] == to_find[j])
                        j++;
        }
        if (j && !to_find[j])
        {
                return (str + i - 1);
        }       
}
return (NULL);
}

int     main(void)
{
        char    str[] = "abcghrjajcabotjskja";
        char    str_to_find[] = "cabot";

        printf("pointeur vers la chaîne = %s\n", ft_strstr(str, str_to_find)    );

        return (0);
}

On parcours les rang de la chaine jusqu’à trouver une ressemblance.
Si ressemblance alors on parcours la chaine to_find et la str en utilisant l’incrémentation de tofind)
Si on a plus de to_find c’est que toute la chaîne est là donc on return le pointeur de la chaine + le compteur de str - 1.

J05 ex 03:
Programme :
#include "main.h"
#include <stdio.h>

int     ft_strcmp(char *s1, char *s2)
{
        while((*s1 || *s2) && *s1++ == *s2++)
        {
                ;
        }
        return (*s2-- - *s1--);
}

int     main(void)
{
        char    s1[] = "AB";
        char    s2[] = "ABC";
        printf ("strcmp = %d\n", ft_strcmp(s1, s2));
        return (0);
}

J05 ex 04 : 
Programme : 

 #include "main.h"
 #include <stdio.h>

int     ft_strncmp(char *s1, char *s2, unsigned int n)
{       
        while((*s1 && *s2) && n-- &&(*s1++ == *s2++))
 {       
        ;
 }
 return ((*s2 - 2) - (*s1- 2));
} 
 
 int     main(void)
 {
   char    s1[] = "JE T'APPELLE";
   char    s2[] = "JE TOLE";
   printf ("ft_strncmp = %d\n", ft_strncmp(s1, s2, 20));
   return (0);
 }

 PAS TROP COMPRIS POURQUOI DÉCRÉMENTER 2 FOIS MAIS ÇA MARCHE COMME ÇA.

 J05 ex 05 :
 Programme :
#include "main.h"
#include <stdio.h>

char    *ft_strupcase(char *str)
{       
        int     i;
        i = 0;

        while (str[i++] && ('a' <= str[i] && str[i] <= 'Z'))
        {
                str[i - 1] -= ('a' - 'A');
        }
        return (str);
}


int     main(void)
{       
        char    str[] = "hjk";
        printf("ft = %s\n", ft_strupcase(str));
 return (0);
}

J05 ex 06 :

#include "main.h"
#include <stdio.h>

char    *ft_strlowcase(char *str)
{
        int     i;
        i = 0;
        while (str[i++] && 'A' <= str[i - 1] <= 'Z')
                str[i - 1] -= ('A' - 'a');
        return (str);
}     

int     main(void)
{
        char    str [] = "FRJAOFJZA";
        printf("str = %s\n", ft_strlowcase(str));
        return (0);
}

J05 ex 07 : 
Programme :

#include <stdio.h>
#include "main.h"

char    *ft_strcapitalize(char *str)
{
        int     i;

        i = 0;

        while (str[i++])
        {
                printf("i = %d\n", i);
                printf("str[i] = %c\n", str[i]);
                if ((i == 1 || !((str[i - 2] >= 'a' && str[i - 2] <= 'z') ||     (str[i - 2] >= 'A' && str[i - 2] <= 'Z'))) && (str[i - 1] >= 'a' && str[i -     2] <= 'z'))

                {
                        str[i - 1] -= ('a' - 'A');
                }
        }
        return (str);
}
 
int     main(void)
{       
        char    str[] = "salut, comment tu vas ? 42mots quarante-deux; cinqu
    ante+et+un";
        printf("capitalize = %s\n", ft_strcapitalize(str));
        return (0);
}

Dans le if la condition [n’est pas (une min et un maj)] ne peut pas marcher parce que le caractère ne peut pas être à la fois une maj et une min.

J05 ex 08 :
Programme :
#include "main.h"
#include <stdio.h>

int     ft_str_is_alpha(char *str)
{       
        int     i;
        i = 0;

        while (*str++)
        {
                if(!(('a' <= *(str - 1) && *(str - 1) <= 'z') || ('A' <= *(s    tr - 1) && *(str - 1) <= 'Z')))
                        return (0);
        }                       
        return (1);
}

int      main(void)
{       
        char    str[] = "chabiboudid55555a";
        printf ("ft = %d\n", ft_str_is_alpha(str));
        return (0);
}
    
La fonction renvoi le nombre de caractère théroqiue si tout c’était bien passé  : je sais ps pourquoi .

Il faut pense à bouger le pointeur de dest à destlen plus loin.

Elle modifie aussi la src en fonction de la taille donné qui doit être supérieur à la taille de la chaine (pas du tableau) au début.

Du coup size > destlen donc on retire à size la taille de dest pour n’ajouter que les caractères que l’on veut/peut.

Ensuite on parcours les pointeurs de src en décrémentant les size si size != 1 OU on l’augmente. et on change les valeur du tableau de dest.
On ajoute l’octet nul à la fin
et on retourne la valeur de théorique de lachaine complète.



J05 ex 09 :
Programme :
#include "main.h"
#include <stdio.h>

int     ft_str_is_numeric(char *str)
{       
        while(*str++)
        {
                if (!('0' <= *(str - 1) && *(str - 1) <= '9'))
                        return 0;
        }
        return 1;
}

 
int     main(void)
{       
        char    str[] = "059204457(230";
        printf("ft = %d\n", ft_str_is_numeric(str));
        return (0);
}    

J05 ex 10 :
Programme :
#include "main.h"
#include <stdio.h>

int     ft_str_is_lowercase(char *str)
{       
        while(*str++)
        {
                if (!('a' <= *(str - 1) && *(str - 1) <= 'z'))
                        return 0;
        }
        return 1;
}

 
int     main(void)
{       
        char    str[] = "hbejvhbhezj";
        printf("ft = %d\n", ft_str_is_lowercase(str));
        return (0);
}

J05 ex 11 :
Programme :
#include "main.h"
#include <stdio.h>

int     ft_str_is_uppercase(char *str)
{       
        while(*str++)
        {
                if (!('A' <= *(str - 1) && *(str - 1) <= 'Z'))
                        return 0;
        }
        return 1;
}

 
int     main(void)
{       
        char    str[] = "FEVHQVJEZ";
        printf("ft = %d\n", ft_str_is_uppercase(str));
        return (0);
}

J05 ex 12 :
Programme :
#include "main.h"
#include <stdio.h>

int     ft_str_is_printable(char *str)
{       
        while(*str++)
        {
                if (!(32 <= *(str - 1) && *(str - 1) <= 126))
                        return 0;
        }
        return 1;
}

 
int     main(void)
{       
        char    str[] = "FEVHQVJEZ";
        printf("ft = %d\n", ft_str_is_printable(str));
        return (0);
}

J05 ex 13 :
Programme :
#include "main.h"
#include <stdio.h>
char    *ft_strcat(char *dest, char *src)
{
        int     dest_len;
        int     i;

        dest_len = 0;
        i = 0;
         
        while (dest[i++])
                dest_len++;
        i = 0;
 
        while (src[i++])
        {   
                dest[dest_len + i - 2] = src[i - 1];
        }
  
        dest[dest_len + i - 2] = '\0';
        return (dest);
}
 
int     main(void)
{       
        char    dest[100] = "Je suis";
        char    src[] = "Francais.";
        printf("ft = %s\n", ft_strcat(dest, src));
        return(0);
}

EST CENSÉ FONCTIONNÉ AU VU DES PRINTS MAIS N'IMPRIME RIEN EN SORTIE.

J05 ex 14 :

#include <stdio.h>
char    *ft_strncat(char *dest, char *src, int nb)
{        
        int     dest_len;
        int     i;

        dest_len = 0;
        i = 0;
         
        while (dest[i++])
                dest_len++;
        i = 0;
 
        while (src[i++] && nb --)
        {   
                dest[dest_len + i - 2] = src[i - 1];
        }
  
        dest[dest_len + i - 2] = '\0';
        return (dest);
}

int     main(void)
{       
        char    dest[100] = "Je suis";
        char    src[100] = "Francais.";
        printf("ft = %s\n", ft_strcat(dest, src, 5));
        return(0);
}

J05 ex 15 :
Programme :
#include "main.h"
#include <stdio.h>
 
int     main(void)
{
        char    dest[100] = "ABC";
        char    src[100] = "12345";

        printf("ft = %d\n", ft_strlcat(dest, src, 6));
        return (0);
}

unsigned int    ft_strlcat(char *dest, char *src, unsigned int size)
{
        unsigned int    srclen; 
        unsigned int    destlen;
        int     i;
         
        destlen = 0;
        srclen = 0;
        i = 0;
          
        while (dest[i++])
                destlen++;
        while (src[i++])
                srclen++;
        i = 0;
         
        size -= destlen;
        dest += destlen;
        if (!size)
                return (destlen + srclen);
        while (*src++) 
                if (size-- != 1 || (size++ && 0))
                        *dest++ = *(src - 1); 
        *dest = '\0';   
        return (destlen + srclen);
}

On concat dans dest u nimbre limité de char finalement rien de dur mais fonctions un peu bizarre.


J05 ex 16 :
Programme :
~    
  1 #include "main.h"
  2 #include <stdio.h>

  1 unsigned int    ft_strlcpy(char *dest, char *src, unsigned int size)
  2 {
  3         int     i;
  4         int     j;
  5         int     srclen;
  6         char *d = dst;
  7         const char *s = src;
  8         size_t n = siz; 
  9         size_t dlen;
 10 
 11         i = 0;
 12         j = 0;
 13         destlen = 0;
 14         srclen = 0;
 15 
 16         while (src[j++] != '\0')
 17                 srclen++;
 18                 
 19         while (n-- != 0 && *d != '\0')
 20                 d++;
 21         dlen = d - dst;
 22         n = siz - dlen;
 23         if (n == 0)
 24                 return(dlen + strlen(s));
 25         while (*s != '\0') {
 26                 if (n != 1) {
 27                         *d++ = *s;
 28                         n--; 
 29                 }       
 30                 s++;
 31         }
 32         *d = '\0';
 33         return(dlen + (s - src));
 34 }

  3 int      main(void)
  4 {
  5         char    dest[100] = "ABC";
  6         char    src[100] = "123";
  7  
  8         printf("ft = %sn", ft_strlcpy(dest, src, 3);
  9         return (0);
 10 }
On copie dans dest u nimbre limité de char finalement rien de dur mais fonctions un peu bizarre.

J05 ex 17 : 
  1 #include <unistd.h>
  2 #include <stdio.h>

  2 int     ft_putchar(char c)
  3 {       
  4         write(1, &c, 1);
  5 }
  6 void    ft_putnbr_base(int nb, char *base)
  7 {
  8         int     i;
  9         int     j;
 10  
 11         i = 0;
 12         j = 0;
 13  
 14         while (base[i++] && (j = i))
 15         {       
 16                 while(base[j++])
 17                 {       
 18                         if (base[i - 1] == base[j - 1] || base[i - 1] =='+' || base [i - 1] == '-')
 19                                 ;
 20                 }
 21         }
 22         if (i-- < 2)
 23                 ;
 24         
 25         if (nb < 0)
 26                 ft_putchar('-');
 27         if (nb <= -i || nb >= i)
 28                 ft_putnbr_base(((nb < 0) ? -(nb / i) : (nb/i)), base);
 29         ft_putchar((nb > 0) ? base[nb % i] : base[-(nb % i)]);
 30         
 31 }

  3 
  4 int     main(void)
  5 {       
  6         int     nb; 
  7         char    base[10] = "abcdefghij";
  8         nb = 1768382561;
 10         
 11         ft_putnbr_base(nb, base);
  9         printf("\n");
  
 12         return (0);
 13 }

On cherche a décomposer le nombre d'origine dans la base. On doit donc le moduler par la llngueur de la base pour en déduire les "unité", puis le diviser pour savoir quoi faire du reste.


J05 ex 18 :
Programme :

#include <stdio.h>
int             ft_in_base(char c, char *base)
{
        int i;

        i = -1;
        while (base[++i])
                if (c == base[i])
                        return (i);
        return (-1);
}

int             ft_baselen(char *base)
{
        int size;

        size = -1;
        while (base[++size])
                if (base[size] == '+' || base[size] == '-' || base[size] == ' '
                        || ft_in_base(base[size], base + size + 1) >= 0
                        || (base[size] >= 9 && base[size] <= 13))
                        return (0);
        return (size);
}

int             ft_atoi_base(char *str, char *base)
{
        int i;
        int n;
        int negative;
        int size;

        if ((size = ft_baselen(base)) < 2)
                return (0);
        while ((*str >= 9 && *str <= 13) || *str == ' ')
                str++;
        negative = 0;
        while (*str == '-' || *str == '+')
                if (*str++ == '-')
                        negative = 1 - negative;
        n = 0;
        while ((i = ft_in_base(*str, base)) >= 0)
        {
                n = n * size + i;
                str++;
        }
        if (negative)
                n *= -1;
        return (n);
}


int     main(void)
{
        char    nb[] = "134";
        char    base[] = "0123456789";
   
        printf("ft = %d\n", ft_atoi_base(nb, base));         
        return (0);
}

On prend le rang du char dans la base => Ca nous donne sa valeur dans la base.
Ensuite on calcule le résultat en le multipliant par la longueur de la base pour le repasser en base 10 puis onajoute le rang du char trouvé.

J05 ex19 :
Programme :
  1 #include <unistd.h>
  2 #include <stdio.h>
  3 void        ft_putchar(char c)
  4 {   
  5     write (1, &c, 1);
  6 }
  7 
  8 void        ft_putstr_non_printable(char *str)
  9 {   
 10     char    base_hexa[] = "0123456789abcdef";
 11     int     baselen;
 12     int     i;
 13     int     j;
 14     int     value;
 15     char    result[2];
 16 
 17     baselen = 16;
 18     
 19     while (*str++)
 20     {
 21         if ((value = *(str - 1)) < 32)
 22         {   
 23             ft_putchar('\\');
 24         for (j = 0; j < 2; j++)
 25             {
 26                 if (value < baselen)
 27                 {
 28                     if (j == 0)
 29                         ft_putchar('0');
 30                     ft_putchar(base_hexa[value % baselen]);
 31                     break;
 32                 }   
 33                 if (value >= baselen)
 34                 {
 35                     ft_putchar(base_hexa[value % baselen]);
 36                     value /= baselen;
 37                 }   
 38             }   
 39         }   
 40         else
 41             ft_putchar(*(str - 1));
 42     }
 43 }   





  3 
  4 int     main(void)
  5 {
  6     char    str[100] = "Coucou\ntu vas bien ?";
  7     ft_putstr_non_printable(str);
  8     return (0);
  9 }


On parcours la chaine en recharchant des char qui valent moin de 32 en suit on les convertit en base hexa.

Si dès le début value < baselen on met 0 puis on printf le modulo.
sinon on print le modulo puis on divise par baselen en on print le résultat.

J < 2 parce que char < 32 donc en hexadecimal pas plus de 2 char dans ce cas.



J05 ex 20 :

#include <unistd.h>
  2 void        ft_putchar(char c)
  3 {   
  4     write(1, &c,1);
  5 }
  6 static void     ft_putnbr_base(long nbr, char *base)
  7 {   
  8     int     b;
  9 
 10     b = 0;
 11     while (base[b++])
 12         ;
 13     if (--b > 2)
 14     {   
 15         if (nbr <= -b || b <= nbr)
 16             ft_putnbr_base((nbr / b), base); 
 17         ft_putchar((nbr > 0) ? base[nbr % b] : base[0]);
 18     }
 19 }
 20 
 21 static void     ft_print_hex_addr(void *addr)
 22 {
 23     long    i;
 24     
 25     i = 0x10000000;
 26     while ((long)addr < (i /= 0x10))
 27         ft_putchar('0');
 28     ft_putnbr_base((long)addr, "0123456789abcdef");
 29 }
 30 
 31 static void     ft_print_hex_content(char *addr, int size)
 32 {   
 33     int     i;
 34 
 35     i = 0;
 36     while (i++ < 0x10)
 37     {
 38         if (i % 2)
 39             ft_putchar(' ');
 40         if (i <= size)
 41         {   
 42             if (-0x10 < *(addr + i - 1) && *(addr + i - 1) < 0x10)
 43                 ft_putchar('0');
 44             ft_putnbr_base(*(addr + i - 1), "0123456789abcdef");
 45         }
 46         else
 47         {   
 48             ft_putchar(' ');
 49             ft_putchar(' ');
 50         }
 51     }
 52 }
 53 
 54 static void     ft_print_printable_content(char *addr, int size)
 55 {   
 56     int     i;
 57     char    c;
 58 
 59     i = 0;
 60     while (i++ < 0x10)
 61     {
 62         c = *(addr + i - 1);
 63         if (i <= size)

 64             ft_putchar((31 < c && c < 127) ? c : '.');
 65     }
 66 }
 67 
 68 void            *ft_print_memory(void *addr, unsigned int size)
 69 {
 70     while (size > 0)
 71     {
 72         ft_print_hex_addr(addr);
 73         ft_putchar(':');
74         ft_print_hex_content(addr, size);
 75         ft_putchar(' ');
 76         ft_print_printable_content(addr, size);
 77         ft_putchar('\n');
 78         size = ((size >= 0x10) ? (size - 0x10) : 0);
 79         addr += 0x10;
 80     }
 81     return (addr);
 82 }

int		ft_putchar(char c)
{
	return (write(1, &c, 1));
}

int		main(void)
{
	char *str;

	str = "C'est qui le patron ?";
	ft_print_memory(str, 160);
	return (0);
}

C’EST LONG MAIS PAS COMPLIQUÉ (PAS FAIT TOUT SEUL JUSTE COPIÉ COLLÉ)

La zone mémoire (160) est arbitraire on met le chiffre qu’on veut.
On prend l’adresse du pointeur de la chaine et on le parcours jusqu’a arriver à 160.

Chaque chose à faire est dans une fonction différente (logique).

Il faut convertir la zone mémoire en hexadecimal / convertir la str en hexa decimal / puthcar les printable et si non_printable = > faire en sorte que les non _printable soit des points.

0x10 vaut 16
0x11 vaut (16 + 1) 17
0x20 vaut (2 x 16) 32
0x100 vaut (16 x 16) 256

Le nombre de 0 définit la valeur de x dans 16 ^x
Le premier nombre définit X dans X x 16








J06 ex 00:

Juste copier coller les fonctions dans les fichiers.
Et faire les manips pour créer la librairie.


gcc -c *c : créer tous les .o des .c

libft_creator.sh 

#!/bin/sh
gcc -Wall -Wextra -Werror -c ft_*.c
ar rc libft.a ft_*.o
ranlib libft.a


POUR COMPILER AVEC LA BIBLIOTHÈQUE QUE L'ON VEUT :
gcc nomDuProgramme.c -L. -lft

ft correspond à libft.a

IL FAUT QUE LE FICHIER .a DE LA LIBRAIRIE SOIT DANS LE MÊME FICHIER.


J06 ex 01 :

Programme :
void    ft_print_program_name(char *name)
{
        while (*name++)
                ft_putchar(*(name - 1)):
        ft_putchar('\n');
}

int     main(int argc, char *argc[])
{
        if (argc)
                ft_print_program_name(argv[0]);
        return (0);
}


J06 ex 02 :

  1 #include <stdio.h>
  2 void    ft_print_params(int argc, char *argv[])
  3 {
  4     int     i;
  5     i = 0;
  6     
  7     printf("argc = %d", argc);
  8     
  9     if (argc > 1)
 10         while (i++ < argc)
 11         {  
 12             while (*argv[i]++)
 13                 ft_putchar(*(argv[i] - 1));
 14             ft_putchar('\n');
 15         }
 16     ft_putchar('\n');
 17 }
 18 
 19 int     main(int argc, char *argv[])
 20 {   
 21     ft_print_params(argc, argv);
 22     return (0);
 23 }
~         

J06 ex 03 :
Programme :

  1 void    ft_rev_params(int ac, char *av[])
  2 {
  3     int     i;
  4  
  5     if (ac > 1)
  6        {
  7            i = (ac);
  8            while (i-- > 0)
  9            {
 10                while (*av[i]++)
 11                {
 12                    ft_putchar(*(av[i] - 1));
 13                }
 14                ft_putchar('\n');
 15            }
 16            ft_putchar('\n');
 17        }
 18 }
 19 
 20 int     main(int argc, char *argv[])
 21 {   
 22     ft_rev_params(argc, argv);
 23     return (0);
 24 }


J06 ex 04 :

Programme :

  1 #include <stdio.h>
  2 char    *ft_strcpy(char *dest, char *src)
  3 {
  4     printf("In strcpy\n");
  5     int i;
  6     i = 0;
  7  
  8     while (src[i++])
  9         dest[i - 1] = src[i - 1];
 10     dest[i - 1] = '\0';
 11     return (dest);
 12 }
 13 
 14 int ft_strcmp(char *s1, char *s2)
 15 {
 16     printf("In strcmp\n");
 17     while ((*s1 || *s2) && *s1++ == *s2++)
 18         ;
 19     printf("*s2 - *s1 = %d\n", (*s2-- - *s1--));
 20     return(*s2-- - *s1--);
 21 }   
 22 
 23 void    ft_sort_params(int ac, char *av[])
 24 {
 25     printf("In sort_param\n");
 26     int     i;
 27     int     j;
 28     char    tmp[100];
 29     
 30     i = 1;
 31     if (ac > 1)
 32        {
 33            while (i < (ac - 1))
 34            {
 35                 if (ft_strcmp(av[i],av[i + 1]) < 0)
 36                 {
 37                     ft_strcpy(tmp, av[i]);
 38                     ft_strcpy(av[i], av[i + 1]);
 39                     ft_strcpy(av[i + 1], tmp);
 40                     i = 1;
 41                 }   
 42                 else
 43                   i++;
 44                    
 45            }
 46            ft_putchar('\n');
 47        }   
 48 }      
 49 
 50 int     main(int argc, char *argv[])
 51 {       
 52     printf("In main\n");
 53     int     i;
 54     
 55     i = 0;
 56     ft_sort_params(argc, argv);
 57     
 58     while (i++ < argc)
 59     {
 60         while (*argv[i]++)
 61             ft_putchar(*(argv[i] - 1));
 62         ft_putchar('\n');
 63     }   
 64     return (0);
 65 } 

J07 ex00 :
  1 #include <stdlib.h>
  1 #include "main.h"
  2 #include <stdio.h>
 
  3 int     ft_strlen(char *str)
  4 {
  5     int     len;
  6     len = 0;
  7     while (*str++)
  8         len++;
  9     return (len);
 10 }
 11 
 12 char    *ft_strdup(char *src)
 13 {
 14     char    *result;
 15     int     i;
 16      
 17     if (!(result = (char*)malloc((ft_strlen(src)) * sizeof(char) + 1)))
 18         return (NULL);
 19     i = 0;
 20     
 21     while (src[i++])
 22         result[i - 1] = src[i - 1];
 23     result[i - 1] = src[i - 1]; 
 24     
 25     return (result);
 26 }  


  3 int     main(int argc, char *argv[])
  4 {
  5     char src[100] = "Bonjour";
  6     printf("ft = %s\n", ft_strdup(src));
  7     return(0);
  8 }


J07 ex 01 :

  1 #include "main.h"
  2 #include <stdio.h>
  1 #include <stdlib.h>
  2 int     *ft_range(int min, int max)
  3 {
  4     int     *result;
  5     int     i;
  6     
  7     if (max - min <= 0)
  8         return (NULL);
  9     
 10     if (!(result = (int*)malloc((max - min) * sizeof(int))))
 11         return (NULL);
 12         
 13     i = 0;
 14     
 15     while(i++ < (max - min))
 16         result[i - 1] = (min + (i - 1));
 17     return (result);
 18 }


  3 int     main(int argc, char *argv[])
  4 {
  5     int     i;
  6     int     *table;
  7     i = 0;
  8    
  9     table = ft_range(2, 10);
 10     
 11     while (i++ < (10 -2))
 12         printf("table[%d] = %d\n",(i - 1), table[i - 1]);
 13     
 14     return(0);
 15 }

J07 ex 02 :

  1 #include <stdlib.h>
  2 #include <stdio.h>
  1 #include "main.h"

  3 
  4 int     ft_abs(int n)
  5 {
  6     return ((n < 0) ? -n : n);
  7 }
  8 
  9 int     ft_ultimate_range(int **range, int min, int max)
 10 {   
 11     int     *result;
 12     int     i;
 13     
 14     if (min >= max)
 15     {
 16         return (0);
 17     }   
 18     
 19     if (!(result = (int*)malloc((sizeof(int) * ft_abs(max - min)))))
 20     {
 21         return (0);
 22     }   
 23     
 24     i = 0;
 25     
 26     while(i++ < ft_abs(max - min))
 27     {
 28         result[i - 1] = (min + (i - 1));
 29     }   
 30     
 31     *range = result;
 32     
 33     return(ft_abs(max - min));
 34 }  



  3 int     main(int argc, char *argv[])
  4 {
  5     int     *table;
  6     int     i;
  7     int     max = -15;
  8     int     min = -2;
  9     printf("%d\n", (max - min));
 10     ft_ultimate_range(&table, -2, 15);
 11     
 12     i = 0;
 13    
 14     while(i++ <= ((max - min) < 0 ? -(max - min) : (max- min)))
 15         printf("table[%d] = %d\n", (i - 1), table[i - 1]);
 16     
 17     return(0);
 18 }

Etonnament on ne peut pas faire ça avec le tableau direct on doit d’abord passer âr un tableau simple puis on assigne le résultat au tableau.



J07 ex 03 :

  1 #include <stdlib.h>
  2 #include <stdio.h>
  1 #include "main.h”
  3 static int      ft_strlen(char *str)
  4 {
  5     char    *ptr;
  6 
  7     ptr = str;
  8     while (*ptr)
  9         ptr++;
 10     return (ptr - str);
 11 }
 12 
 13 static char     *ft_strcpy(char *dest, char *src)
 14 {
 15     int     i;
 16 
 17     i = 0;
 18     while (src[i++])
 19         dest[i - 1] = src[i - 1];
 20     dest[i - 1] = '\0';
 21     return (dest);
 22 }
 23 
 24 char            *ft_concat_params(int argc, char **argv)
 25 {
 26     int     i;
 27     int     length;
 28     char    *result;
 29 
 30     i = 0;
 31     length = 0;
 32     while (++i < argc)
 33         length += ft_strlen(argv[i]);
 34     length += (argc - 1);
 35     if (!(result = (char*)malloc(sizeof(char) * length)))
 36         return (NULL);
 37     i = 0;
 38     length = 0;
 39     while (++i < argc)
 40     {
 41         if (i > 1)
 42             result[length++] = '\n';
 43         ft_strcpy((result + length), argv[i]);
 44         length += ft_strlen(argv[i]);
 45     }
 46     return (result);
 47 }

  3 int     main(int argc, char *argv[])
  4 {
  5     printf("ft = %s\n", ft_concat_params(argc, argv));
  6     return(0);
  7 }

J07 ex 04 :

1 #include <stdlib.h>
  2 #include <stdio.h>
  3 
  4 char  *ft_strncpy(char *dest, char *src, unsigned int nb)
  5 {   
  6     int     i;
  7 
  8     i = 0;
  9     
 10     while (i++ < nb && src[i - 1])
 11         dest[i - 1] = src[i - 1];
 12     dest[i - 1] = '\0';
 13     
 14     return (dest);
 15 }
 16 
 17 int     ft_wordlen(char *str)
 18 {
 19     char *ptr;
 20     
 21     ptr = str;
 22     
 23     while (*ptr != ' ' && *ptr != '\n' && *ptr != '\t' && *ptr != '\0')
 24         *ptr++; 
 25         
 26     return (ptr - str);
 27 }   
 28 
 29 
 30 
 31 int     ft_nb_char(char *str)
 32 {
 33     int     i;
 34     int     nb_char;
 35     
 36     i = 0;
 37     nb_char = 0;
 38     
 39     while(str[i++])
 40     {
 41         if (str[i - 1] != ' ' && str[i - 1] != '\n' && str[i - 1] != '\t' && str[i -
 42         {
 43             i++;
 44             nb_char++;
 45         }   
 46     }   
 47    return (nb_char);
 48 }  
 49 
 50 
 51 
 52 char  **ft_split_whitespaces(char *str)
 53 {
 54     int     i;
 55     char    **result;
 56     char    *tmp;
 57     
 58     while (*str == ' ' || *str == '\t' || *str == '\n')
 59         *str++; 
 60         
 61     if (!(result = (char**)malloc((sizeof(char*) * ft_nb_char(str)) + 1)))
 62         return (NULL);
 63         
 64     i = 0;
 65     while (ft_nb_char(str))
 66     {
 67         while (*str == ' ' || *str == '\t' || *str == '\n')
 68             *str++; 
 69         if (!(tmp = (char*) malloc(sizeof(char) * ft_wordlen(str))))
 70             return (NULL);
 71             
 72         tmp = ft_strncpy(tmp, str, ft_wordlen(str));
 73         
74         tmp[ft_wordlen(str)] = '\0';
 75         result[i++] = tmp;
 76         str += ft_wordlen(str);
 77     }
 78     result[i] = 0;
 79     return (result);
 80 }

  3 
  4 char get_word(char *word)
  5 {
  6     char    **result;
  7 
  8     result = ft_split_whitespaces(word);
  9     while (*result++)
 10     {
 11         while (*(*(result - 1))++)
 12             ft_putchar(*(*(result - 1) - 1));
 13         ft_putchar('\n');
 14     }
 15 }
 16 
 17 int     main(int argc, char *argv[])
 18 {
 19     char    str[] = "Antoine ne  bois\npas\tde jus";
 20 
 21 
 22     printf("words = %d\n", get_word(str));
 23     return(0);
 24 }

J07 ex 05 :
  1 #include "main.h"
  2 #include <stdio.h>

  2 void    ft_print_words_tableau(char **tab)
  3 {
  4     while (*tab++)
  5     {
  6         while (*(*(tab -1))++)
  7             ft_putchar(*(*(tab - 1) -1));
  8         ft_putchar('\n');
  9     }
 10 }

  3 
  4 int     main(void)
  5 {   
  6     char    str[] = "JE  m'appelle Antoine\nj'aime  les \t les cabots.";
  7  
  8     ft_print_words_tableau(ft_split_whitespaces(str));
  9  
 10     return(0);
 11 }


J07 ex 06:

  1 #include <stdlib.h>
  2 #include <stdio.h>
  1 #include "main.h"
  3 
  3 int     ft_in_base(char c, char *base)
  4 {   
  5     int i;
  6     
  7     i = -1;
  8     while (base[++i])
  9         if (c == base[i])
 10             return (i);
 11     return (-1);
 12 }
 13 
 14 int     ft_checkbase(char *base)
 15 {
 16     int i;
 17 
 18     i = -1;
 19     while (base[++i])
 20         if (base[i] == '+' || base[i] == '-' || base[i] == ' '
 21             || ft_in_base(base[i], base + i + 1) >= 0
 22             || (base[i] >= 9 && base[i] <= 13))
 23             return (0);
 24     return ((i < 2) ? 0 : i);
 25 }
 26 
 27 int     ft_atoi_base(char *str, char *base, int size)
 28 {
 29     int i;
 30     int n;
 31     int negative;
 32 
 33     while ((*str >= 9 && *str <= 13) || *str == ' ')
 34         str++;
 35     negative = 0;
 36     while (*str == '-' || *str == '+')
 37         if (*str++ == '-')
 38             negative = 1 - negative;
 39     n = 0;
 40     while ((i = ft_in_base(*str++, base)) >= 0)
 41         n = n * size + i;
 42     if (negative)
 43         n *= -1;
 44     return (n);
 45 }
 46 
 47 int     ft_nbrlen(unsigned int n, unsigned int base_size)
 48 {
 49     if (n < base_size)
 50         return (1);
 51     return (1 + ft_nbrlen(n / base_size, base_size));
 52 }
 53 
 54 char    *ft_convert_base(char *nbr, char *base_from, char *base_to)
 55 {
 56     char            *dest;
 57     unsigned int    nb;
 58     int             size;
 59     int             i;
 60     int             n;
 61 
 62     n = ft_checkbase(base_from);
 63     if (!(n && (size = ft_checkbase(base_to))))
 64         return (NULL);
 65     n = ft_atoi_base(nbr, base_from, n);
 66     nb = (n < 0) ? -n : n;
 67     i = ft_nbrlen(nb, size) + ((n < 0) ? 1 : 0);
 68     if (!(dest = malloc((i + 1) * sizeof(char))))
 69         return (NULL);
 70     dest[i] = '\0';
 71     while (i--)
 72     {
 73         dest[i] = base_to[nb % size];
 74         nb /= size;
 75     }
 76     if (n < 0)
 77         dest[0] = '-';
 78     return (dest);
 79 }

  3 
  4 int     main(void)
  5 {
  6     char    base_from[] = "0123456789";
  7     char    base_to[] = "01";
  8     char    nbr[] = "-225";
  9 
 10     printf("ft = %s\n", ft_convert_base(nbr, base_from, base_to));
 11 
 12     return (0);
 13 }

FONCTIONNE MAIS REVOIR LA LOGIQUE.

 J07 ex 07 :
  1 #include "main.h"
  2 #include <stdio.h>
  1 #include <stdlib.h>
  2 
  3 int     ft_is_separator(char *str, char *charset)
  4 {
  5     while (*charset)
  6         if (*str == *charset++)
  7             return (1);
  8     return (0);
  9 }
 10 
 11 int     ft_wordlen(char *str, char *charset)
 12 {
 13     int i;
 14 
 15     i = 0;
 16     while (str[i] && !ft_is_separator(str + i, charset))
 17         i++;
 18     return (i);
 19 }
 20 
 21 int     ft_wordcount(char *str, char *charset)
 22 {
 23     int i;
 24     int w;
 25 
 26     w = 0;
 27     while (*str)
 28     {
 29         while (*str && ft_is_separator(str, charset))
 30             str++;
 31         i = ft_wordlen(str, charset);
 32         str += i;
 33         if (i)
 34             w++;
 35     }
 36     return (w);
 37 }
 38 
 39 char    *ft_wordcpy(char *src, int n)
 40 {
 41     char    *dest;
 42 
 43     if (!(dest = malloc((n + 1) * sizeof(char))))
 44         return (NULL);
 45     dest[n] = '\0';
 46     while (n--)
 47         dest[n] = src[n];
 48     return (dest);
 49 }
 50 
 51 char    **ft_split(char *str, char *charset)
 52 {
 53     char    **t;
 54     int     size;
 55     int     i;
 56     int     n;
 57 
 58     size = ft_wordcount(str, charset);
 59     if (!(t = malloc((size + 1) * sizeof(char*))))
 60         return (NULL);
 61     i = -1;
 62     while (++i < size)
 63     {
 64         while (*str && ft_is_separator(str, charset))
 65             str++;
 66         n = ft_wordlen(str, charset);
 67         if (!(t[i] = ft_wordcpy(str, n)))
 68             return (NULL);
 69         str += n;
 70     }
 71     t[size] = 0;
 72     return (t);
 73 }


  3 
  4 char get_word(char *word, char *charset)
  5 {
  6     char    **result;
  7 
  8     result = ft_split(word, charset);
  9     while (*result++)
 10     {
 11         while (*(*(result - 1))++)
 12             ft_putchar(*(*(result - 1) - 1));
 13         ft_putchar('\n');
 14     }
 15 }
 16 
 17     
 18 int     main(void)
 19 {
 20     char    charset[] = "n/0P";
 21     char    str[] = "Bonjour, J'ai 10 moti/ivation.";
 22 

 24     return (0);
 25 }


J08 ex 00 :

#ifndef FT_H
#define FT_H

int     ft_putchar(char c);
void    ft_putstr(char *str);
int     ft_strcmp(char *s1, char *s2);
int     ft_strlen(char *str);
void    ft_swap(int *a, int *b);

#endif

J08 ex01 :

#ifndef FT_BOOLEAN_H
#define FT_BOOLEAN_H

void    ft_putstr(char *str);
t_bool  ft_is_even(int nbr);

#endif

J08 ex 01 :

ft_boolean.h :

  1 #ifndef FT_BOOLEAN_H
  2 #define FT_BOOLEAN_H
  3 
  4 #include <unistd.h>
  5 
  6 #define SUCCESS     0
  7 #define EVEN_MSG    "I have a pair number of argument\n"
  8 #define ODD_MSG     "I have an impair number of argument\n"
  9 
 10 #define EVEN(nbr)   ((nbr % 2) ? 0 : 1)
 11 
 12 typedef char    t_bool;
 13 #define TRUE    1
 14 #define FALSE   0
 15 
 16 #endif


  1 #include "ft_boolean.h"
  2 
  3 void    ft_putstr(char  *str)
  4 {
  5     while (*str)
  6         write(1, str++, 1);
  7 }
  8 
  9 t_bool  ft_is_even(int nbr)
 10 {
 11     return ((EVEN(nbr)) ? TRUE : FALSE);
 12 }
 13 
 14 int             main(int argc, char **argv)
 15 {
 16     (void)argv;
 17     if (ft_is_even(argc - 1) == TRUE)
 18         ft_putstr(EVEN_MSG);
 19     else
 20         ft_putstr(ODD_MSG);
 21     return(SUCCESS);
 22 }




 EN GROS IL FAUT DÉFINIR TOUS CE QUI EST EN MAJUSCULE DANS LE .C
MÊME POUR TRUE ET FALSE IL FAUT DÉFINIR LA VALEUR DANS LE .h

J08 ex 02 :

  1 #ifndef FT_ABS_H
  2 #define FT_ABS_H
  3 
  4 #define ABS(Value)  ((Value < 0) ? -Value : Value)
  5 
  6 #endif


  1 #include "ft_abs.h"
  2 #include <stdio.h>
  3 
  4 int     main(void)
  5 {   
  6     int     nb;
  7  
  8     nb = -45;
  9  
 10     printf("%d\n", ABS(nb));
 11  
 12     return (0);
 13 }


J08 ex 03 : 

  1 typedef struct t_point t_point;
  2 
  3 struct t_point
  4 {
  5     int     x;
  6     int     y;
  7 };

  1 #include "ft_point.h"
  2 #include <stdio.h>
  3 void    set_point(t_point *point)
  4 {   
  5     point->x = 42;
  6     point->y = 21;
  7 }
  8 
  9 int     main(void)
 10 {   
 11     t_point     point;
 12  
 13     set_point(&point);
 14     
 15     printf("x = %d\n", point.x);
 16     printf("y = %d\n", point.y);
 17     return (0);
 18 }

BIEN PENSE AU ; À LA FIN DE LA STRUCTURE !

LE -> EST POUR UN POINTEUR   LE . POUR UNE VARIABLE
DANS LA FONCTION ON NE MET PAS LE TYPE DE LA VARIABLE MAIS LE NOM DE LA STRUCTURE AVANT.




LES DEUX DERNIER EXOS JE COMRPEND PAS CE QUI NE MARCHE PAS A REVOIR.




J09 ex00:

Programme :
~        
  1 #include <unistd.h>
  1 #include "main.h"
  2 
  3 int     main(void)
  4 {
  5     ft_generic();
  6     return (0);
  7 }

  2 void    ft_generic(void)
  3 {
  4     char     str[] = "Tu tu tu tu ; Tu tu tu tu";
  5     int     i;
  6 
  7     i = 0;
  8 
  9     while (str[i++])
 10         write(1, &(str[i - 1]), 1);
 11     
 12     write(1, "\n", 1);
 13 }


J09 ex 01 :

  1 #include <stdio.h>
  1 #include "main.h"
  2 void    ft_takes_place(int hour)
  3 {
  4     int     X;
  5     int     Y;
  6     int     i;
  7     char    day1;
  8     char    day2;
  9 
 10     
 11     X = hour;
 12     Y = X + 1;
 13     
 14     if (0 <= hour && hour < 12)
 15     {    
 16          day1 = 'A';
 17          day2 = 'A';
 18     }    
 19     
 20     if (12 < hour && hour  < 24)
 21     {
 22         day1 = 'P';
 23         day2 = 'P';
 24         X -= 12;
 25     }   
 26     
 27     if (hour == 12)
 28     {
 29         Y = 1;
 30         day1 = 'A';
 31         day2 = 'P';
 32     }   
 33     
 34     if (hour == 23)
 35     {
 36         day1 = 'P';
 37         day2 = 'A';
 38         Y = 0; 
 39     }   
 40     
 41     if (hour == 24)
 42     {
 43         X = 0;
 44         Y = 1;
 45         day1 = 'A';
 46         day2 = 'A';
 47     }   
 48     
 49     printf("THE FOLLOWING TAKES PLACE %d.00 %c.M. AND %d.00 %c.M.\n", X, day1, Y, day2)
 50 }

  2 
  3 int     main(void)
  4 {
  5     int     i;
  6     
  7     i = 0;
  8     
  9     while (i++ < 25)
 10         ft_takes_place((i - 1));
 11     
 12     return (0);
 13 }
~      

J09 ex 02:

cat $1 | grep -i “bomber“ | grep -i “nicolas” | grep -v “Sally” | awk ‘{print $(NF - 1) “ “ $(NF - 2)}’ | tr -d ‘BomberNicolas’


CA FONCTIONNE MAIS JE SAIS PAS DE QUEL RÉPERTOIRE ON PARLE.

j09 EX 03 :

JE NE COMPREND PAS COMMENT FAIRE AUCUNE RÉPONSE TROUVÉE


J09 ex04 :

  1 #include "main.h"
  2 #include <stdio.h>:w

  1 char    *ft_rot42(char *str)
  2 {
  3     char    alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
  4     char    result[ft_strlen(str) + 1];
  5     int     a;
  6     int     i;
  7     int     j;
  8     int     letter_value;
  9     
 10     a = (42 % 26);
 11     i = 0;
 12     
 13     while (str[i++])
 14     {
 15         j = 0;
 16         while (alphabet[j++])
 17         {
 18             if (str[i - 1] == ' ')
 19                 break;
 20             if (str[i - 1] == alphabet[j - 1])
 21             {
 22                 if (((j - 1) + a) <= 26)
 23                     str[i - 1] = alphabet[(j - 1) + a];
 24                 if (((j - 1) + a) > 26)
 25                     str[i - 1] = alphabet[((j - 1) + a - 26)];
 26                 break;
 27             }   
 28         }   
 29     }   
 30     str[i] = '\0';
 31     return (str);
 32 }


  3 
  4 int     main(void)
  5 {   
  6     char    str[] = "JE SUIS POLONAIS";
  7     
  8     printf("ft = %s\n",ft_rot42(str));
  9     return (0);
 10 }



J09 ex 05 :

int     ft_bouton(int i, int j, int k)
{
        if ((i >= j && i <= k) || (i <= j && i >= k))
                return (i);
        if ((j >= i && j <= k) || (j <= i || j >= k))
                return (j);
        if ((k >= j && k <= i) || (k <= j && k >= i))
                return (k);
}


J09 ex 06 :

  1 #include <stdlib.h>
  2 #include "ft_ultimator.h"
  3 
  4 void    ft_destroy(char ***factory)
  5 {   
  6     int     i;
  7     int     j;
  8     
  9     i = 0;
 10     j = 0;
 11     
 12     while (factory[i++])
 13     {   
 14         while (factory[i - 1][j++])
 15         {   
 16             free(factory[i - 1][j - 1];
 17         }
 18         free(factory[i - 1];
 19         j = 0;
 20     }
 21     free(factory);
 22 }


J09 ex 07 :

  1 #include <stdio.h>
  2 #include "main.h"

  2 unsigned int    ft_collatz_conjecture(unsigned int base)
  3 {   
  4     int     i;
  5     printf("base = %d\n", base);
  6     if (base == 1)
  7         return (0);
  8         
  9     if (base % 2 == 0)
 10         base = (base / 2);
 11     
 12     else
 13         base = ((3 * base) + 1);
 14     return (ft_collatz_conjecture(base) + 1);
 15 
 16 }


  3 
  4 int     main(void)
  5 {   
  6     int     base;
  7     
  8     base = 15;
  9     
 10     printf("ft = %d\n", ft_collatz_conjecture(base));
 11     return (0);
 12 }


J09 ex 08 :

  4 void    ft_putchar(char c)
  5 {
  6     write (1, &c, 1);
  7 }
  8 
  9 void    ft_print_alert(void)
 10 {
 11     char    str[] = "Alert!!!\n";
 12     int     i;
 13     
 14     i = 0;
 15     
 16     while (str[i++] != '\0')
 17         ft_putchar(str[i - 1]);
 18 }       
 19 
 20 int ft_check_word(char *av,char  *trig)
 21 {
 22     int     i;
 23     
 24     i = 0;
 25     
 26     while (av[i] == trig[i])
 27     {
 28         if (av[i] == trig[i] && av[i] == '\0')
 29             return (1);
 30         i++;
 31     }   
 32     return (0);
 33 }   
 34 
 35 int     ft_spy(int ac, char **av)
 36 {
 37     int     i;
 38     int     j;
 39     char    trig1[] = "president";
 40     char    trig2[] = "attack";
 41     char    trig3[] = "Powers";
 42     
 43     i = 0;
 44     j = 0;
 45     
 46     while (i++ < ac)
 47     {
 48         if (ft_check_word(av[i - 1], trig1) == 1)
 49         {
 50             ft_print_alert();
 51             return (0);
 52         }   
 53         
 54         if (ft_check_word(av[i - 1], trig2) == 1)
 55         {
 56             ft_print_alert();
 57             return (0);
 58         }   
 59         
 60         if (ft_check_word(av[i - 1], trig3) == 1)
 61         {
 62             ft_print_alert();
 63             return (0);
 64         }   
 65         
 66     }   
 67 }   
 68 
 69 int     main(int argc, char *argv[])
 70 {
 71     ft_spy(argc, argv);
 72     return (0);
 73 }


J09 ex 09 :

  1 #! /bin/bash
  2 CMD=`ifconfig | grep "inet " | cut -d' ' -f2`
  3 NUM=`ifconfig | grep "inet " | cut -d' ' -f2 | wc -l | tr -d ' '`
  4 
  5 if [ "$NUM" -eq "2" ]; then
  6     echo "Je suis perdu!"
  7 else
  8     echo "$CMD"
  9 fi
~      

IFCONFIG PERMET D’AFFICHER LES INFORMATIONS LIÉES AU RÉSEAUX ET IP
GREP REPERT LES SUITES DE BYTES COREEPONDANT AU PRAMÈTRE
CUT PERMET DE SÉLECTIONNER LE CHAMP QUI NOUS INTERRESSE EN METTANT EN OPTION -D QUI COUPE LE PARAMÈTRE ET -F QUI SÉLECTIONNE LE CHAMP À IMPRIMER

WC COMPTE LE NOMBRE DE LIGNE 
ET TRADUIT LES LIGNES AVEC LES OPTIONS DONNÉES EN L’OCCURENCE ON COUPE LES ESPACES.




j09 EX 10

  1 #include <stdio.h>
  2 void    ft_scrambler(int ***a, int *b, int *******c, int ****d)
  3 {   
  4     int     tmp;
  5     int     tmp2;
  6  
  7     tmp = *******c;
  8     *******c = ***a;
  9  
 10     tmp2 = ****d;
 11     ****d = tmp;
 12  
 13     tmp = *b;
 14     *b = tmp2;
 15  
 16     ***a = tmp;
 17 }


LE MAIN EST BEAUCOUP TROP CHIANT VOIR IMPOSSIBLME À FAIRE MAIS LA LOGIQUE EST SIMPLE DONC PAS BESOIN DE VÉRIFIER.




J09 ex 11 :

  1 #ifndef FT_PERSO_H
  2 #define FT_PERSO_Hi
  3 
  4 #define SAVE_AUSTIN_POWER   "SAVE_AUSTIN_POWER"
  5 
  6 typedef struct t_perso
  7 {
  8     char    *name;
  9     double  life;
 10     int     age;
 11     char    *profession;
 12 }                           t_perso;
 13 
 14 #endif



J09 ex12 ::

FT_DOOR.H :

  1 #ifndef FT_DOOR_H
  2 #define FT_DOOR_H
  3 
  4 #define OPEN 1
  5 #define CLOSE 0
  6 
  7 #define TRUE 1
  8 #define CLOSE 0
  9 
 10 #define EXIT_SUCCESS 0
 11 
 12 typedef struct t_door t_door;
 13 
 14 struct t_door
 15 {   
 16     int state;
 17 };
 18 
 19 #include "ft_door.c"
 20 int     open_door(t_door *door);
 21 int  close_door(t_door *door);
 22 int     is_door_open(t_door *door);
 23 int     is_door_close(t_door *door);
 24 
 25 
 26 #endif
~         


FT_DOOR.C : 

  1 #include <unistd.h>
  2 void ft_putstr(char *str)
  3 {   
  4     int     i = 0;
  5     
  6     while (*str++)
  7         write(1, (str - 1), 1);
  8     write(1, "\n", 1);
  9 }
 10 
 11 int open_door(t_door *door)
 12 {   
 13     ft_putstr("Door opening...");
 14     door->state = OPEN;
 15     return (TRUE);
 16 }
 17 
 18 int close_door(t_door *door)
 19 {   
 20     ft_putstr("Door closing...");
 21     door->state = CLOSE;
 22     return (TRUE);
 23 }
 24 
 25 int is_door_open(t_door *door)
 26 {   
 27     ft_putstr("Door is open ?");
 28     door->state = OPEN;
 29 
 30 }
 31 
 32 int is_door_close(t_door *door)
 33 {   
 34     ft_putstr("Door is close?");
 35     door->state = CLOSE;
 36 }

MAIN.C :

  1 #include <stdlib.h>
  2 #include "ft_door.h"
  3 
  4 int     main(void)
  5 {
  6     t_door  door;
  7 
  8     open_door(&door);
  9     if (is_door_close(&door))
 10         open_door(&door);
 11     if (is_door_open(&door))
 12         close_door(&door);
 13     if (door.state = OPEN)
 14         close_door(&door);
 15     return (EXIT_SUCCESS);
 16 }  


J09 ex13 :
  1 #include <stdio.h>
  2 int     ft_compact(char **tab, int lenght)
  3 {   
  4     printf("Dans la fonction\n");
  5     int     i;
  6     int     j;
  7     int     new_len;
  8     i = 0;
  9     j = 0;
 10     
 11     while (i < lenght)
 12     {   
 13         printf("tab[i = %d] == %s\n", (i), tab[i]);
 14         while (*(tab + i))
 15         {
 16             printf("i = %d\n", i);
 17             i++;
 18         }
 19         
 20         printf("Dans le if\n");
 21         j = i;
 22         while (j++ < lenght)
 23         {   
 24             printf("tab[j = %d] == %s\n", (j - 1), tab[j - 1]);
 25             
 26             if (*(tab + (j - 1)))
 27             {   
 28                 *(tab + (i - 1)) = *(tab + (j - 1));
 29                 *(tab + (j - 1)) = NULL;
 30             }
 31         }
 32     }
 33     
 34     i = 0;
 35     new_len = 0; 
 36     while (*(tab + (i++)))
 37         new_len++;
 38     
 39     return (new_len);
 40 }
~      
  1 #include "main.h"
  2 #include <stdio.h>
  3 
  4 int     ft_tablen(char **tab)
  5 {
  6     printf("Dans tablen\n");
  7     int     i;
  8     int     len;
  9     i = 0;
 10     len = 0;
 11     
 12     while (*tab[i++])
 13     {   
 14         printf("tab[i = %d] = %s", i, tab[i - 1]);
 15         len++;
 16     }
 17     
 18     return (len);
 19 }
 20 
 21 int     main(void)
 22 {   
 23     char    *tab[100];
 24     char    str1[] = "TU";
 25     char    str2[] = "Antoine";
 26     char    str3[] = "34";
 27     int     tablen;
 28     
 29     tab[0] = str1;
 30     tab[3] = str2;
 31     tab[4] = str3;
 32     tablen = ft_tablen(tab);
 33     printf("tablen = %d\n", tablen);
 34     
 35     printf("ft = %d\n", ft_compact(tab, tablen)); 
 36     
 37     return (0);
 38 }

NORMALEMENT LA FOCNTION EST PAS LOIN DE FONCTIONNER MAIS JE NE SAIS PAS COMMENT COMPTER LES CASES VIDES DANS LA LEN. DONC JE NE PEUX PAS VÉRIFIER.











MAKEFILE :

J10 ex 00 :

Makefile : 
  1 NAME = libft.a
  2 
  3 SRC = srcs/ft_putchar.c srcs/ft_putstr.c srcs/ft_strcmp.c srcs/ft_strlen.c srcs/ft_swap.c
  4 
  5 all: $(NAME)
  6 
  7 $(NAME): 
  8     gcc -Wall -Wextra -Werror -c $(SRC)
  9     ar rc $(NAME) *.o 
 10     ranlib $(NAME)
 11 
 12 clean:
 13     /bin/rm -f *.o
 14 
 15 flcean: 
 16     clean
 17     /bin/rm -f $(NAME)
 18 
 19 re:
 20     fclean 
 21     all

BIEN PENSER À METTRE LES .C ET .H DANS LES BONS FICHIERS ET MOFIFIER LES LIENS DE INCLUDES.

J10 ex 01 :

   1 void        ft_foreach(int *tab, int lenght, void (*f)(int))
  2 {
  3     int     i;
  4     
  5     i = 0;
  6     
  7     while (i++ < lenght)
  8     {
  9         f(tab[i - 1]);
 10     }   
 11 }


 1 #include "ft_foreach.h"
  2 #include <stdio.h>
  3 
  4 void    ft_addone(int nb)
  5 {
  6    printf("nb + 1 = %d\n", nb + 1);
  7 }
  8 
  9 
 10 int         main(void)
 11 {   
 12     int     tab[] = {1, 2, 3, 4};
 13     int     i;
 14     void(*f)(int);
 15     
 16     i = 0;
 17     f = &ft_addone;
 18     
 19     ft_foreach(tab, 4, f); 
 20     while (i ++ < 4)
 21         printf("tab = %d\n", tab [i - 1]);
 22     return (0);
 




J10 ex 02:
 1 #include <stdlib.h>
  2 
  3 int         *ft_map(int *tab, int lenght, int(*f)(int))
  4 {
  5     int     i;
  6     int     *result;
  7  
  8     i = 0;
  9     result = malloc(sizeof(int) * lenght);
 10     
 11     while (i++ < lenght)
 12     {
 13         result [i - 1] = f(tab[i - 1]);
 14     }   
 15 } 

 1 #include "ft_map.h"
  2 #include <stdio.h>
  3 
  4 int    ft_addone(int nb)
  5 {
  6    return (nb + 1);
  7 }
  8 
  9 
 10 int         main(void)
 11 {
 12     int     tab[] = {1, 2, 3, 4};
 13     int     i;
 14     int(*f)(int);
 15 
 16     i = 0;
 17     f = &ft_addone;
 18 
 19     ft_map(tab, 4, f);    
 20     return (0);
 21 }


DANS L’INTIALISATION DU POINTEUR DE FONCTION :
	ADAPTER LE TYPE DU POINTEUR.


J10 ex 03 :

 1 #include <stdio.h>
  2 
  3 int         ft_any(char **tab, int(*f)(char*))
  4 {
  5     int     i;
  6     
  7     i = 0;
  8     
  9     while (tab[i++])
 10     {
 11         if (f(tab[i - 1]) == 1)
 12             return (1);
 13     }       
 14     return (0);
 15 }


 1 #include "ft_any.h"
  2 #include <stdio.h>
  3 
  4 int     ft_randomft(char *str)
  5 {
  6     int     i;
  7     i = 0;
  8 
  9     while (str[i++])
 10     {
 11         printf("str[%d] = %c\n", i - 1, str[i - 1]);
 12         if (str[i - 1] == '2')
 13                 return (1);
 14     }
 15 }
 16 
 17 int         main(void)
 18 {   
 19     char    *tab[4];
 20     char    str[] = "Bonjour,";
 21     char    str1[] = "Je vais bien !";
 22     char    str2[] = "Et2 vous ?";
 23     char    str3[] = "\0";
 24     int     (*f)(char*);
 25     
 26     tab[0] = str;
 27     tab[1] = str1;
 28     tab[2] = str2;
 29     tab[3] = '\0';
 30     f = &ft_randomft;
 31     
 32     printf("ft  %d\n", ft_any(tab, f));
 33     return (0);
 34 }


Il faut faire pointer le tableau vers 0 donc le dernier pointeur du tableau = ‘\0’.


J10 ex 04 :

 1 int         ft_count_if(char **tab, int(*f)(char*))
  2 {
  3 
  4     int     result;
  5     int     i;
  6     result = 0;
  7     i = 0; 
  8  
  9     while (tab[i++])
 10     {
 11         if (f(tab[i - 1]) == 1)
 12             result++; 
 13     }       
 14     return (result);
 15 }  

 1 #include "ft_count_if.h"
  2 
  3 int     ft_nb_whitespaces(char *str)
  4 {
  5     int     i;
  6     int     result;
  7     i = 0;
  8  
  9     while (str[i++])
 10         if (str[i - 1] == ' ')
 11             return (1);
 12  
 13     return (0);
 14 }
 15 
 16 int         main(void)
 17 {   
 18     char    *tab[4];
 19     char    str[] = "Bonjour,";
 20     char    str1[] = "Jesuis";
 21     char    str2[] = "étudianteninfo.";
 22     int    (*f)(char*);
 23     
 24     tab[0] = str;
 25     tab[1] = str1;
 26     tab[2] = str2;
 27     tab[3] = '\0';
 28     f = &ft_nb_whitespaces;
 29     
 30     printf("ft = %d\n", ft_count_if(tab, f));
 31     return (0);
 32 }


J10 ex 05 :



 1 int         ft_is_sort(int *tab, int lenght, int(*f)(int, int))
  2 {
  3     int     i;
  4     int     j;
  5     
  6     i = 0;
  7     j = 0;
  8  
  9     while (i++ < lenght - 1)
 10     {
 11         j = i - 1;
 12         while (j++ < lenght)
 13         {
 14             if (f(tab[i - 1], tab[j - 1]) > 0)
 15                 return (0);
 16         }       
 17     }   
 18     return (1);
 19 


 1 #include <stdio.h>
  2 #include "ft_is_sort.h"
  3 
  4 int     ft_check_sort(int nb1, int nb2)
  5 {
  6     return (nb1 - nb2);
  7 }
  8 
  9 int         main(void)
 10 {
 11     int     tab[] = {1, 2, 3, 4};
 12     int     (*f)(int, int);
 13 
 14     f = &ft_check_sort;
 15 
 16     printf("ft = %d\n", ft_is_sort(tab, 4, f));
 17     return (0);
 18 }



J10 ex 05 :



J10 ex 06 :

Makefile :

 1 NAME = do-op
  2 
  3 SRC = ft_do-op.c
  4 
  5 all : $(NAME)
  6 
  7 $(NAME) :
  8     gcc -Wall -Wextra -Werror $(SRC) -o $(NAME)
  9     ar rc $(NAME) *.o
 10 
 11 clean :
 12     /bin/rm -f *.o


Pour les fonction en vrai rien de difficile :
Vérifier les argument dan une fonction ft_debug;
Convertir les arguments nombre en int pour les cakcuker dans une fonction;
fonction qui sera définit en parcourant une string avec tous le opérateurs et le rang de l’opé qui correspond correspond à un tableau d’addresse de fonctions qui sera assigner à un pointeur.

BIEN PENSER À DÉBUGGER AU FUR ET À MESURE.
Faire attention aux différentes règle sur les fichiers parce que les fonctions s remplissent vites et les fichiers aussi.



J11 ex 00 :

  1 #include "ft_list.h"
  2 
  3 t_list      *ft_create_elem(void *data)
  4 {
  5     t_list  *tmp;
  6 
  7     tmp = malloc(sizeof(t_list));
  8 
  9     if (tmp)
 10     {
 11         tmp->data = data;
 12         tmp->next = NULL;
 13     }
 14 
 15     return tmp;
 16 }
~    

On récupère le type de la structure via l'inclusion
on créer une variable à partir de ça et on malloc la taille du type.
Si tmp à une valeur (si l'allocutoion à marcher) On assigne les valeur aux pointeurs.


J11 ex 01 :

  1 #include "ft_list.h"
  2 #include <stdlib.h>
  3 void    ft_list_push_back(t_list **begin_list, void *data)
  4 {
  5     t_list      *list;
  6 
  7      list = *begin_list;
  8     if (!list)
  9         list = ft_create_elem(data);
 10     else if (list)
 11     {
 12         while ((list)->next)
 13         {
 14             list = list->next;
 15         }
 16         list->next = ft_create_elem(data);
 17     }
 18 }

Intialisation d'une liste dans une autre fonction (paramètre **begin_list)
Ici on récupère le le pointeur sur le pointeur de la structure pour modifier la structure directement (d'où le void)
on initialise une variable de type structure. On lui donne une valeur égale à begin_list.
Si la variable n'a pas de valeur alors on intite directement une structure avec la fonction.
Si il y a une valeur on parcours les pointeurs des structres successives jusqu'à ne plus trouver de vaeur (NULL).
On remplace alros le pointeur NULL par le pointeur de la nouvelle strucutre. dont le next vaut NULL.

J11 ex 02 :

